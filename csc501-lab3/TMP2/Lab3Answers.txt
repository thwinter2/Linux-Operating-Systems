1) By using a Priority Ceiling approach we could solve the priority inversion problem. In this type of approach, the priority ceiling will be set greater than the highest priority of the processes, then whenever a process acquires a lock that process's priority will match the priority ceiling.
	Because the process now has the maximum priority of all of the other processes, the process with the shared resource (i.e. lock) will not be preempted by the other processes and may complete the locked section without any fear of interruption. Once the locked section is complete and the lock is freed, the process's priority can go back down to its original setting and then another process can be set to the ceiling.
	This dynamic use of adjusting processes' priorities also prevents deadlock because a process at the priority ceiling will not be waiting on another process to finish (and therefore prevented from being blocked) or be interrupted before a lock has been freed.

2) It looks like there could be data race condition in the buffer because the semaphore is initialized to 10, meaning potentially 10 processes could be writing to the memory buffer. If 2 processes happen to write to the same address of the buffer at the exact same time, then there will be data race condition.
	Additionally, the do_update function only has a Read lock, which means readers are not excluded from acquiring the lock at the same time. This would result in data being written simultaneously in the buffer if two writers acquire the Read lock.